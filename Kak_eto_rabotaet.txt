Даны целые числа a0...a6.
Получить для x = 1, 3, 4 значения p(x+1) - p(x), где
p(y) = a6*y^6 + a5y^5 + ... + a0.


У меня есть 2 функции для решения:
1 - main_proc
2 - procedure

main_proc находит разность между p(x+1) и p(x)
procedure это и есть p(x)
в ней есть циклы
1 - cycle_mul
2 - cycle_sum

cycle_mul умножает каждый элемент массива на соответсв. степень X,
а затем помещает это в стек
Сначала в стек записывается a0, так как его ни на что умножать не надо
В итоге в стеке 7 элементов

На каждой итерации цикла из массива в регистр dx читается значение,
что бы это происходило нужно регистр, в котором записан адрес массива
(di) увеличивать на 2 (так как массив из элементов в 16 бит, был бы
8 битный - увеличивали бы на 1)
Так же в цикле считается степень X. X хранится в ax, si каждую итерацию
умножается на ax (si - нужная степень)
Значение из dx (эл. массива) и степень (si) перемножаются с помощью
imul - знаковое умножение (с которым я поебался)
+ для каждого элемента массива есть вывод в консоль (ибо нет отладчика
и хрен ты без этого какую ошибку найдёшь или прогу проверишь)

cycle_sum - запись суммы всех элементов стека в eax

Доп ин-фа:
Посмотри сколько весят регистры, сколько знаковых/беззнаковых чисел
можно в них записать
Посмотри на объявление переменных, массивов (dw, db, dup(?))

Всё, что ниже моих процедур - процедуры ввода/вывода знаковых и 
беззнаковых слов и байтов
В программе максимум можно вывести беззнаковое слово - 65535
или знаковое 32 с хуем тыщи, хотя
в функциях при умножении и возведении в степень всё норм прописано
и в итоге ответ ограничивается регистром eax (только, что бы его
вывести надо весь вывод перелопачивать)

Массивы, которые я использовал:
1, 2, 3, 4, 4, 4, 4
1, 2, -3, 4, -4, 4, 4

Там, когда X = 5, т.е P(5+1) - p(5) получается не верный результат
как раз из за вывода.
Можешь их использовать и Палкину сразу сказать, что заеблась писать
и не стала делать вывод 4-х байтных значений.